#!/usr/bin/env python3
"""
run - Cross-platform CLI tool for Deft framework v0.3.7
A layered framework for AI-assisted development

Works on: macOS, Linux, Windows, FreeBSD
Requires: Python 3.6+
Optional: rich (for enhanced output and better UX)
"""

import sys
import os
import shutil
import subprocess
from pathlib import Path
from datetime import datetime
from typing import List, Optional

VERSION = "0.3.7"

# Try to import rich for enhanced experience
try:
    from rich.console import Console
    from rich.prompt import Prompt, Confirm
    from rich.panel import Panel
    from rich.rule import Rule
    from rich.text import Text
    HAS_RICH = True
    console = Console()
except ImportError:
    HAS_RICH = False
    console = None
    # Fall back to readline on Unix for arrow key support
    try:
        import readline  # Enable history and arrow keys on Unix
    except ImportError:
        pass  # Windows: basic input() still works

# Try to import prompt_toolkit
try:
    import prompt_toolkit
    HAS_PROMPT_TOOLKIT = True
except ImportError:
    HAS_PROMPT_TOOLKIT = False

# Output helpers
def print_header(text: str):
    """Print main command header"""
    if HAS_RICH:
        console.print(Panel(f"[bold cyan]{text}[/bold cyan]", border_style="cyan"))
    else:
        print(f"\n{'=' * 60}")
        print(f"  {text}")
        print('=' * 60)

def print_section(text: str):
    """Print section header within a command"""
    if HAS_RICH:
        console.rule(f"[cyan]{text}[/cyan]")
    else:
        print(f"\n{'-' * 60}")
        print(f"  {text}")
        print('-' * 60)

def print_info(msg: str):
    """Print info message"""
    if HAS_RICH:
        console.print(f"[blue]‚Ñπ[/blue] {msg}")
    else:
        print(f"‚Ñπ {msg}")

def print_success(msg: str):
    """Print success message"""
    if HAS_RICH:
        console.print(f"[green]‚úì[/green] {msg}")
    else:
        print(f"‚úì {msg}")

def print_warn(msg: str):
    """Print warning message"""
    if HAS_RICH:
        console.print(f"[yellow]‚ö†[/yellow] {msg}")
    else:
        print(f"‚ö† {msg}")

def print_error(msg: str):
    """Print error message"""
    if HAS_RICH:
        console.print(f"[red]‚úó[/red] {msg}")
    else:
        print(f"‚úó {msg}")

# Legacy aliases for backward compatibility
info = print_info
success = print_success
warn = print_warn
error = print_error

def get_script_dir() -> Path:
    """Get the directory where this script is located"""
    return Path(__file__).parent.absolute()

def usage():
    """Print usage information"""
    hint = ""
    if not HAS_RICH:
        # Get the Python executable path for accurate install command
        python_exe = sys.executable
        stdlib_path = Path(sys.base_prefix) / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}"
        is_externally_managed = (stdlib_path / "EXTERNALLY-MANAGED").exists()
        
        install_cmd = f"{python_exe} -m pip install"
        if is_externally_managed:
            install_cmd += " --break-system-packages"
        install_cmd += " rich"
        
        hint = f"\nüí° Tip: Install rich for enhanced output and better UX:\n   {install_cmd}\n"
    
    if HAS_RICH:
        print_header(f"Deft CLI v{VERSION}")
        console.print("""
[bold]Usage:[/bold] run <command> [options]
       python run <command> [options]       # If not executable
       python3 run <command> [options]      # If not executable

[bold cyan]Commands:[/bold cyan]
  [green]bootstrap[/green]       Set up your user preferences (user.md)
  [green]project[/green]         Create/update project configuration (project.md)
  [green]spec[/green]            Generate project specification (interactive interview)
  [green]install[/green]         Install deft framework in a project directory
  [green]reset[/green]           Reset configuration files to default state
  [green]validate[/green]        Validate deft configuration files
  [green]update[/green]          Update deft framework to latest version
  [green]doctor[/green]          Check system dependencies and configuration
  [green]help[/green]            Show this help message

[bold cyan]Examples:[/bold cyan]
  run bootstrap              # First-time setup
  run project                # Configure current project
  run spec                   # Generate SPECIFICATION.md
  run install ~/my-project   # Install deft in a project
  run reset                  # Reset config files (interactive)
  run reset --all            # Reset all config files (no prompts)
  run validate               # Check configuration is valid

For more information: [link]https://github.com/visionik/deft[/link]
""")
    else:
        print(f"""Deft CLI v{VERSION}{hint}

Usage: run <command> [options]
       python run <command> [options]       # If not executable
       python3 run <command> [options]      # If not executable

Commands:
  bootstrap       Set up your user preferences (user.md)
  project         Create/update project configuration (project.md)
  spec            Generate project specification (interactive interview)
  install         Install deft framework in a project directory
  reset           Reset configuration files to default state
  validate        Validate deft configuration files
  update          Update deft framework to latest version
  doctor          Check system dependencies and configuration
  help            Show this help message

Examples:
  run bootstrap              # First-time setup
  run project                # Configure current project
  run spec                   # Generate SPECIFICATION.md
  run install ~/my-project   # Install deft in a project
  run reset                  # Reset config files (interactive)
  run reset --all            # Reset all config files (no prompts)
  run validate               # Check configuration is valid

For more information: https://github.com/visionik/deft
""")

def ask_input(prompt_text: str, default: str = "") -> str:
    """Read user input with optional default
    
    Args:
        prompt_text: The prompt to display
        default: Default value if user presses Enter
    
    Returns:
        User input or default value
    """
    try:
        # Priority: prompt_toolkit (best editing) > rich > basic input
        if HAS_PROMPT_TOOLKIT:
            from prompt_toolkit import prompt as pt_prompt
            # Add colored prefix if rich is also available
            if HAS_RICH:
                prefix = "\033[36m?\033[0m "  # Cyan question mark with ANSI codes
                display_prompt = f"{prefix}{prompt_text}"
            else:
                display_prompt = prompt_text
            
            value = pt_prompt(display_prompt + ": ", default=default)
            return value if value else default
        elif HAS_RICH:
            # Add colored question mark prefix
            formatted_prompt = f"[cyan]?[/cyan] {prompt_text}"
            value = Prompt.ask(formatted_prompt, default=default if default else None)
            return value if value else default
        else:
            # Fall back to basic input() with readline support (if available on Unix)
            if default:
                value = input(f"{prompt_text} [{default}]: ")
            else:
                value = input(f"{prompt_text}: ")
            return value if value else default
    except (EOFError, KeyboardInterrupt):
        return default

def ask_choice(prompt_text: str, choices: List[str], default: str = None) -> str:
    """Read user choice from list
    
    Args:
        prompt_text: The prompt to display
        choices: List of valid choices
        default: Default choice
    
    Returns:
        User's choice
    """
    try:
        if HAS_RICH:
            # Add colored question mark prefix
            formatted_prompt = f"[cyan]?[/cyan] {prompt_text}"
            return Prompt.ask(formatted_prompt, choices=choices, default=default)
        else:
            # Fallback: show numbered list
            print(f"\n{prompt_text}")
            for i, choice in enumerate(choices, 1):
                print(f"  {i}. {choice}")
            while True:
                ans = input("Enter number: ")
                try:
                    idx = int(ans) - 1
                    if 0 <= idx < len(choices):
                        return choices[idx]
                except ValueError:
                    pass
                print("Invalid choice, try again.")
    except (EOFError, KeyboardInterrupt):
        return default if default else choices[0]

def ask_confirm(prompt_text: str, default: bool = False) -> bool:
    """Read yes/no confirmation
    
    Args:
        prompt_text: The prompt to display
        default: Default value
    
    Returns:
        True if user confirms, False otherwise
    """
    try:
        # Priority: prompt_toolkit > rich > basic input
        if HAS_PROMPT_TOOLKIT:
            from prompt_toolkit import prompt as pt_prompt
            # Add colored prefix if rich is also available
            if HAS_RICH:
                prefix = "\033[36m?\033[0m "  # Cyan question mark with ANSI codes
                display_prompt = f"{prefix}{prompt_text}"
            else:
                display_prompt = prompt_text
            
            suffix = " (Y/n): " if default else " (y/N): "
            response = pt_prompt(display_prompt + suffix, default="")
            if not response:
                return default
            return response.strip().lower() in ('y', 'yes')
        elif HAS_RICH:
            # Add colored question mark prefix
            formatted_prompt = f"[cyan]?[/cyan] {prompt_text}"
            return Confirm.ask(formatted_prompt, default=default)
        else:
            suffix = " (Y/n) " if default else " (y/N) "
            response = input(f"{prompt_text}{suffix}")
            if not response:
                return default
            return response.strip().lower() in ('y', 'yes')
    except (EOFError, KeyboardInterrupt):
        return default

# Legacy aliases for backward compatibility
read_input = ask_input
read_yn = ask_confirm

def cmd_bootstrap(args: List[str]):
    """Bootstrap command - set up user.md"""
    print_header(f"Deft v{VERSION} - Bootstrap")
    print()
    
    script_dir = get_script_dir()
    user_file = script_dir / "core" / "user.md"
    
    # Check if file exists
    if user_file.exists() and "--force" not in args:
        warn("user.md already exists. Use --force to overwrite.")
        if not read_yn("Overwrite existing user.md?"):
            return 0
    
    print()
    print_section("User Preferences Setup")
    
    # Gather user information
    user_name = read_input("Your name (how AI should address you)")
    coverage = read_input("Default coverage threshold (default: 85%)", "85")
    
    print()
    print_section("Programming Languages")
    info("Select your primary programming languages (comma-separated):")
    print("  1. Python")
    print("  2. Go")
    print("  3. TypeScript")
    print("  4. C++")
    print("  5. Other")
    lang_selection = read_input("Selection (e.g., 1,3)")
    
    # Map selections to language names
    lang_map = {
        "1": "Python",
        "2": "Go",
        "3": "TypeScript",
        "4": "C++",
        "5": "Other"
    }
    
    lang_nums = [s.strip() for s in lang_selection.split(',')]
    languages = []
    for num in lang_nums:
        if num in lang_map:
            languages.append(f"- {lang_map[num]}")
    
    languages_str = '\n'.join(languages) if languages else "- (None specified)"
    
    print()
    print_section("Custom Rules")
    custom_rules = read_input("Any custom rules or preferences (optional, press Enter to skip)")
    
    # Generate user.md
    user_content = f"""# User Preferences

Legend (from RFC2119): !=MUST, ~=SHOULD, ‚ââ=SHOULD NOT, ‚äó=MUST NOT, ?=MAY.

**Rule Precedence**: This file has HIGHEST precedence - overrides all other deft rules.

## Name

Address the user as: **{user_name}**

## Default Standards

**Coverage**: ! ‚â•{coverage}% test coverage for all projects (unless project.md specifies otherwise)

**Primary Languages**:
{languages_str}

## Custom Rules

{custom_rules if custom_rules else "No custom rules defined yet."}

## Workflow Preferences

- ~ Use task-based automation (Taskfile)
- ! Always run `task check` before committing
- ~ Follow Conventional Commits

## AI Behavior

- ~ Be direct and concise
- ~ Proactively suggest improvements
- ! Explain tradeoffs for major decisions

---

**Note**: You can edit this file anytime to update your preferences.
**See**: [../main.md](../main.md) for framework overview.
"""
    
    user_file.parent.mkdir(parents=True, exist_ok=True)
    user_file.write_text(user_content, encoding='utf-8')
    
    success(f"Created user.md at {user_file}")
    print()
    info("user.md defines your personal preferences and default standards.")
    print()
    
    # Always offer to configure project settings
    print()
    print_section("Next Steps")
    if read_yn("Would you like to run 'run project' now?"):
        print()
        return cmd_project([])
    else:
        print()
        info("You can run 'run project' later to configure your project")
        return 0

def cmd_project(args: List[str]):
    """Project command - configure project.md"""
    print_header(f"Deft v{VERSION} - Project Configuration")
    print()
    info("This command creates project.md, which defines YOUR project's specifics:")
    info("  ‚Ä¢ Tech stack and programming language")
    info("  ‚Ä¢ Project type (CLI, API, Web App, Library, etc.)")
    info("  ‚Ä¢ Quality standards (test coverage thresholds)")
    info("  ‚Ä¢ Workflow commands (task check, task test, etc.)")
    print()
    info("This file tells AI assistants how to build and maintain YOUR project.")
    info("It works alongside the general Deft guidelines in ./deft/")
    print()
    
    project_file = Path("./deft/core/project.md")
    
    # Check if we're in a project directory
    if not Path("./deft").is_dir():
        warn("No ./deft directory found. Run 'run install' first or specify a project directory.")
        if read_yn("Install deft in current directory?"):
            cmd_install(["."])
        else:
            return 1
    
    # Gather project information
    project_name = read_input("Project name")
    
    print()
    info("Select project type (comma-separated if multiple):")
    print("  1. CLI (Command-line interface)")
    print("  2. TUI (Terminal UI)")
    print("  3. REST API")
    print("  4. Web App")
    print("  5. Library")
    print("  6. Other")
    type_selection = read_input("Selection")
    
    type_map = {
        "1": "CLI",
        "2": "TUI",
        "3": "REST API",
        "4": "Web App",
        "5": "Library",
        "6": "Other"
    }
    
    type_nums = [s.strip() for s in type_selection.split(',')]
    project_types = []
    custom_type = ""
    
    for num in type_nums:
        if num == "6":
            custom_type = read_input("Enter custom project type")
            project_types.append(custom_type)
        elif num in type_map:
            project_types.append(type_map[num])
    
    project_types_str = ", ".join(project_types)
    
    print()
    info("Select primary programming language:")
    print("  1. Python")
    print("  2. Go")
    print("  3. TypeScript")
    print("  4. C++")
    lang_num = read_input("Selection")
    
    plang_map = {
        "1": "Python",
        "2": "Go",
        "3": "TypeScript",
        "4": "C++"
    }
    primary_lang = plang_map.get(lang_num, "Python")
    
    print()
    proj_coverage = read_input("Coverage threshold (default: 85%)", "85")
    tech_stack = read_input("Tech stack details (e.g., 'Flask + SQLAlchemy' or 'React + Next.js')")
    
    # Generate project.md
    tech_stack_str = f" - {tech_stack}" if tech_stack else ""
    today = datetime.now().strftime("%Y-%m-%d")
    
    project_content = f"""# {project_name} Project Guidelines

Legend (from RFC2119): !=MUST, ~=SHOULD, ‚ââ=SHOULD NOT, ‚äó=MUST NOT, ?=MAY.

**‚ö†Ô∏è See also**: [../main.md](../main.md) | [../languages/{primary_lang.lower()}.md](../languages/{primary_lang.lower()}.md)

## Project Configuration

**Tech Stack**: {project_types_str} using {primary_lang}{tech_stack_str}

## Workflow

```bash
task check         # Pre-commit (fmt, lint, test, test:coverage)
task test:coverage # Coverage (‚â•{proj_coverage}%)
task build         # Build project
task clean         # Clean artifacts
```

## Secrets

```bash
ls secrets/
# Add your secrets to secrets/ directory
# Use .example files as templates
```

## Standards

**Quality:**
- ! Run `task check` before every commit
- ! Achieve ‚â•{proj_coverage}% coverage overall + per-module
- ! Store secrets in `secrets/` dir
- ~ Provide `.example` templates for secrets

**Telemetry:**
- ~ Structured logging (see [../tools/telemetry.md](../tools/telemetry.md))
- ~ Sentry.io for error tracking
- ? Distributed tracing for complex workflows

## Project-Specific Rules

(Add your custom rules here)

---

**Generated by**: run v{VERSION}
**Date**: {today}
"""
    
    project_file.parent.mkdir(parents=True, exist_ok=True)
    project_file.write_text(project_content, encoding='utf-8')
    
    success(f"Created project.md at {project_file}")
    print()
    info("project.md defines your project's tech stack, workflow, and quality standards.")
    print()
    
    # Prompt to run spec generation
    print()
    print_section("Next Steps")
    info("Generate a detailed specification via AI interview")
    info("The 'spec' command creates PRD.md with your project requirements,")
    info("which an AI assistant will use to interview you and generate SPECIFICATION.md.")
    print()
    if read_yn("Would you like to run 'run spec' now?"):
        print()
        return cmd_spec([])
    else:
        print()
        info("You can run 'run spec' later to generate your specification.")
        return 0

def cmd_spec(args: List[str]):
    """Spec command - generate specification via interview"""
    print_header(f"Deft v{VERSION} - Specification Generator")
    print()
    info("This command creates PRD.md (Product Requirements Document) with:")
    info("  ‚Ä¢ Your project's core features and requirements")
    info("  ‚Ä¢ An AI interview template to drill into details")
    print()
    info("After creating PRD.md, you'll:")
    info("  1. Give PRD.md to your AI assistant")
    info("  2. The AI conducts an in-depth interview about requirements")
    info("  3. The AI generates SPECIFICATION.md with full implementation plan")
    info("  4. The AI can then implement the spec")
    print()
    info("This ensures nothing important is overlooked before coding starts.")
    print()
    
    prd_file = Path("./PRD.md")
    
    if prd_file.exists() and "--force" not in args:
        warn("PRD.md already exists. Use --force to overwrite.")
        return 1
    
    # Try to read project name from project.md
    project_file = Path("./deft/core/project.md")
    spec_name = ""
    if project_file.exists():
        try:
            content = project_file.read_text(encoding='utf-8')
            # Extract project name from first heading (e.g., "# MyProject Project Guidelines")
            for line in content.split('\n'):
                if line.startswith('# ') and 'Project Guidelines' in line:
                    spec_name = line.replace('# ', '').replace(' Project Guidelines', '').strip()
                    break
        except:
            pass
    
    if spec_name:
        info(f"Project name from project.md: {spec_name}")
        if not read_yn("Use this name?"):
            spec_name = read_input("Project name")
    else:
        spec_name = read_input("Project name")
    
    spec_desc = read_input("Brief description (1-2 sentences)")
    
    print()
    info("Enter project features (one per line, empty line to finish):")
    features = []
    while True:
        feature = read_input("  Feature")
        if not feature:
            break
        features.append(feature)
    
    # Build feature list
    feature_list = '\n'.join([f"{i+1}. {f}" for i, f in enumerate(features)])
    
    # Read the make-spec template
    script_dir = get_script_dir()
    template_file = script_dir / "templates" / "make-spec.md"
    
    if not template_file.exists():
        error(f"Template file not found: {template_file}")
        return 1
    
    template_content = template_file.read_text(encoding='utf-8')
    
    # Replace placeholders
    template_content = template_content.replace("[project name]", spec_name)
    template_content = template_content.replace(f"I want to build [project name]", f"I want to build {spec_name}")
    
    # Generate PRD
    today = datetime.now().strftime("%Y-%m-%d")
    full_path = Path.cwd() / prd_file
    
    prd_content = f"""# Product Requirements Document: {spec_name}

**Generated**: {today}
**Status**: Ready for AI Interview

## Initial Input

**Project Description**: {spec_desc}

**I want to build {spec_name} that has the following features:**
{feature_list}
---

{template_content}
"""
    
    prd_file.write_text(prd_content, encoding='utf-8')
    
    success(f"Created PRD.md at {prd_file}")
    info("Next steps:")
    info(f"  1. Open your AI assistant (Claude, Warp.dev, etc.)")
    info(f"  2. Ask your AI to read and run {full_path}")
    info(f"  3. The AI will conduct a detailed interview based on the template")
    info(f"  4. AI will generate the final SPECIFICATION.md")
    info(f"  5. You can review the SPECIFICATION.md if you want")
    info(f"  6. Ask your AI to implement {Path.cwd()}/SPECIFICATION.md")
    info(f"  7. Your AI may ask you some questions like 'should I continue', just say yes or please continue")
    return 0

def cmd_install(args: List[str]):
    """Install command - install deft framework in a project"""
    target_dir = Path(args[0]) if args else Path(".")
    
    print_header(f"Deft v{VERSION} - Installation")
    print()
    info("This command installs the Deft framework in your project directory.")
    info("It will create:")
    info("  ‚Ä¢ ./deft/        - Framework files (guidelines, templates, references)")
    info("  ‚Ä¢ ./secrets/        - Directory for API keys and credentials (.gitignored)")
    info("  ‚Ä¢ ./docs/           - Project documentation")
    info("  ‚Ä¢ Taskfile.yml      - Task automation config (if not present)")
    info("  ‚Ä¢ .gitignore        - Ensures secrets aren't committed (if not present)")
    print()
    info(f"Target directory: {target_dir.absolute()}")
    print()
    
    if not target_dir.exists():
        error(f"Directory does not exist: {target_dir}")
        return 1
    
    # Change to target directory
    original_dir = Path.cwd()
    os.chdir(target_dir)
    
    try:
        deft_dir = Path("./deft")
        
        # Check if deft already exists
        already_installed = deft_dir.exists()
        if already_installed:
            warn("Deft already installed in this directory.")
            if not read_yn("Reinstall?"):
                # Still offer to run project even if not reinstalling
                print()
                print_section("Next Steps")
                if read_yn("Would you like to run 'run project' now?"):
                    print()
                    return cmd_project([])
                else:
                    return 0
        
        # Copy deft framework
        info("Copying deft framework...")
        script_dir = get_script_dir()
        
        if deft_dir.exists():
            shutil.rmtree(deft_dir)
        
        shutil.copytree(script_dir, deft_dir)
        
        # Create project-specific files
        Path("secrets").mkdir(exist_ok=True)
        Path("docs").mkdir(exist_ok=True)
        Path("secrets/.gitkeep").touch()
        
        # Create .gitignore for secrets
        gitignore = Path(".gitignore")
        if not gitignore.exists():
            gitignore.write_text("secrets/*\n!secrets/.gitkeep\n!secrets/*.example\n", encoding='utf-8')
        
        # Create basic Taskfile if it doesn't exist
        taskfile = Path("Taskfile.yml")
        if not taskfile.exists():
            taskfile_content = """version: '3'

tasks:
  default:
    desc: List all tasks
    cmds:
      - task --list
    silent: true

  check:
    desc: Run all pre-commit checks
    cmds:
      - echo "Add your check commands here"
      - task fmt
      - task lint
      - task test

  fmt:
    desc: Format code
    cmds:
      - echo "Add your format command here"

  lint:
    desc: Lint code
    cmds:
      - echo "Add your lint command here"

  test:
    desc: Run tests
    cmds:
      - echo "Add your test command here"

  test:coverage:
    desc: Run tests with coverage
    cmds:
      - echo "Add your coverage command here"
"""
            taskfile.write_text(taskfile_content, encoding='utf-8')
            success("Created Taskfile.yml")
        
        success("Deft installed successfully!")
        print()
        
        # Prompt to run project configuration
        print_section("Next Steps")
        if read_yn("Would you like to run 'run project' now?"):
            print()
            return cmd_project([])
        else:
            print()
            info("You can run these commands later:")
            info("  ./deft/run project     # Configure this project")
            info("  ./deft/run bootstrap   # Set up user preferences")
            return 0
    
    finally:
        os.chdir(original_dir)

def cmd_validate(args: List[str]):
    """Validate command - check deft configuration"""
    info("Validating Deft configuration...")
    print()
    
    script_dir = get_script_dir()
    errors = 0
    
    # Check for required files
    required_files = [
        "main.md",
        "core/user.md",
        "coding/coding.md",
        "REFERENCES.md"
    ]
    
    for file in required_files:
        filepath = script_dir / file
        if filepath.exists():
            success(f"Found: {file}")
        else:
            error(f"Missing: {file}")
            errors += 1
    
    # Check for at least one language file
    lang_dir = script_dir / "languages"
    if lang_dir.exists() and list(lang_dir.glob("*.md")):
        success("Language files present")
    else:
        error("No language files found in languages/")
        errors += 1
    
    # Check for broken links (simple check)
    info("Checking for common broken links...")
    # Note: Python implementation could be more sophisticated
    
    print()
    if errors == 0:
        success("Validation passed! Deft configuration is valid.")
        return 0
    else:
        error(f"Validation failed with {errors} error(s).")
        return 1

def cmd_doctor(args: List[str]):
    """Doctor command - check system dependencies"""
    info("Deft Doctor - Checking system...")
    print()
    
    warnings = 0
    
    # Check for required tools
    def check_command(cmd: str, name: str, required: bool = False):
        nonlocal warnings
        if shutil.which(cmd):
            success(f"{name} is installed")
        else:
            if required:
                error(f"{name} not found - required")
            else:
                warn(f"{name} not found - install from https://taskfile.dev" if cmd == "task" 
                     else f"{name} not found")
                warnings += 1
    
    check_command("task", "task (Taskfile)")
    check_command("git", "git", required=True)
    check_command("python3", "python3")
    check_command("go", "go")
    check_command("node", "node")
    
    # Check directory structure
    print()
    info("Checking Deft structure...")
    
    script_dir = get_script_dir()
    expected_dirs = ["core", "languages", "interfaces", "tools", "swarm", "templates", "meta"]
    
    for dir_name in expected_dirs:
        dir_path = script_dir / dir_name
        if dir_path.is_dir():
            success(f"Directory: {dir_name}/")
        else:
            warn(f"Missing directory: {dir_name}/")
            warnings += 1
    
    print()
    if warnings == 0:
        success("System check passed!")
    else:
        warn(f"System check completed with {warnings} warning(s).")
    
    return 0

def cmd_update(args: List[str]):
    """Update command - update deft framework"""
    info("Deft update functionality not yet implemented")
    warn("Manual update: Replace deft directory with latest version from repository")
    return 0

def cmd_reset(args: List[str]):
    """Reset command - reset configuration files to default/empty state"""
    print_header(f"Deft v{VERSION} - Reset")
    print()
    info("This command resets deft configuration files to their default state.")
    info("You can choose which files to reset:")
    print()
    info("  ‚Ä¢ user.md          - Your personal preferences (in ./deft/core/)")
    info("  ‚Ä¢ project.md        - Project configuration (in ./deft/core/)")
    info("  ‚Ä¢ PRD.md            - Product requirements document (in current directory)")
    info("  ‚Ä¢ SPECIFICATION.md  - Generated specification (in current directory)")
    print()
    
    # Check what exists
    script_dir = get_script_dir()
    user_file = script_dir / "core" / "user.md"
    project_file = Path("./deft/core/project.md")
    prd_file = Path("./PRD.md")
    spec_file = Path("./SPECIFICATION.md")
    
    files_to_reset = []
    
    # Check each file and ask if user wants to reset it
    if "--all" in args:
        # Reset all without asking
        if user_file.exists():
            files_to_reset.append(("user.md", user_file, True))
        if project_file.exists():
            files_to_reset.append(("project.md", project_file, False))
        if prd_file.exists():
            files_to_reset.append(("PRD.md", prd_file, False))
        if spec_file.exists():
            files_to_reset.append(("SPECIFICATION.md", spec_file, False))
    else:
        # Ask for each file
        if user_file.exists():
            if read_yn("Reset user.md to default template?"):
                files_to_reset.append(("user.md", user_file, True))
        
        if project_file.exists():
            if read_yn("Delete project.md?"):
                files_to_reset.append(("project.md", project_file, False))
        
        if prd_file.exists():
            if read_yn("Delete PRD.md?"):
                files_to_reset.append(("PRD.md", prd_file, False))
        
        if spec_file.exists():
            if read_yn("Delete SPECIFICATION.md?"):
                files_to_reset.append(("SPECIFICATION.md", spec_file, False))
    
    if not files_to_reset:
        print()
        info("No files to reset.")
        return 0
    
    # Confirm
    print()
    warn("The following files will be reset/deleted:")
    for name, _, _ in files_to_reset:
        warn(f"  ‚Ä¢ {name}")
    print()
    
    if "--all" not in args and not read_yn("Are you sure you want to continue?"):
        info("Reset cancelled.")
        return 0
    
    # Perform reset
    print()
    for name, filepath, reset_to_default in files_to_reset:
        if reset_to_default:
            # Reset user.md to default template
            default_content = """# User Preferences

Legend (from RFC2119): !=MUST, ~=SHOULD, ‚ââ=SHOULD NOT, ‚äó=MUST NOT, ?=MAY.

**Rule Precedence**: This file has HIGHEST precedence - overrides all other deft rules.

## Name

Address the user as: **(Your Name)**

## Default Standards

**Coverage**: ! ‚â•85% test coverage for all projects (unless project.md specifies otherwise)

**Primary Languages**:
- (Add your languages here)

## Custom Rules

No custom rules defined yet.

## Workflow Preferences

- ~ Use task-based automation (Taskfile)
- ! Always run `task check` before committing
- ~ Follow Conventional Commits

## AI Behavior

- ~ Be direct and concise
- ~ Proactively suggest improvements
- ! Explain tradeoffs for major decisions

---

**Note**: You can edit this file anytime to update your preferences.
**See**: [../main.md](../main.md) for framework overview.
"""
            filepath.write_text(default_content, encoding='utf-8')
            success(f"Reset {name} to default template")
        else:
            # Delete file
            filepath.unlink()
            success(f"Deleted {name}")
    
    print()
    success("Reset complete!")
    info("Run 'run bootstrap' or 'run project' to reconfigure.")
    return 0

def check_prompt_toolkit():
    """Check if prompt_toolkit is available and offer to help install it"""
    if not HAS_PROMPT_TOOLKIT:
        print()
        info("run works better with prompt_toolkit (arrow keys, history, tab completion)")
        try:
            response = input("Would you like installation instructions? (y/N) ").strip().lower()
            if response in ('y', 'yes'):
                print()
                success("To install prompt_toolkit:")
                print()
                # Get the Python executable path
                python_exe = sys.executable
                
                # Try to determine if this is an externally-managed environment
                # by checking for the EXTERNALLY-MANAGED file (PEP 668)
                stdlib_path = Path(sys.base_prefix) / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}"
                is_externally_managed = (stdlib_path / "EXTERNALLY-MANAGED").exists()
                
                if is_externally_managed:
                    print(f"  {python_exe} -m pip install --break-system-packages prompt_toolkit")
                    print()
                    warn("Your Python is externally-managed (PEP 668) by your package manager.")
                    info("The --break-system-packages flag allows installing Python packages directly.")
                    info("Alternative: Use a virtual environment or pipx for isolated installations.")
                    info("More info: https://peps.python.org/pep-0668/")
                else:
                    print(f"  {python_exe} -m pip install prompt_toolkit")
                print()
                info("After installing, re-run your command:")
                print(f"  {' '.join(sys.argv)}")
                print()
                return True  # Exit after showing instructions
        except (EOFError, KeyboardInterrupt):
            print()
    return False  # Continue normally

def main():
    """Main command dispatcher"""
    if len(sys.argv) < 2:
        usage()
        return 0
    
    # Check for prompt_toolkit and offer help (only for interactive commands)
    command = sys.argv[1]
    interactive_commands = ['bootstrap', 'project', 'spec', 'install']
    if command in interactive_commands and check_prompt_toolkit():
        return 0  # Exit after showing install instructions
    
    args = sys.argv[2:]
    
    commands = {
        'bootstrap': cmd_bootstrap,
        'project': cmd_project,
        'spec': cmd_spec,
        'install': cmd_install,
        'reset': cmd_reset,
        'validate': cmd_validate,
        'doctor': cmd_doctor,
        'update': cmd_update,
        'help': lambda _: usage(),
        '--help': lambda _: usage(),
        '-h': lambda _: usage(),
        'version': lambda _: print(f"Deft CLI v{VERSION}"),
        '--version': lambda _: print(f"Deft CLI v{VERSION}"),
        '-v': lambda _: print(f"Deft CLI v{VERSION}"),
    }
    
    if command in commands:
        try:
            return commands[command](args)
        except KeyboardInterrupt:
            print()
            warn("Operation cancelled by user")
            return 130
        except Exception as e:
            error(f"Error: {e}")
            return 1
    else:
        error(f"Unknown command: {command}")
        print()
        usage()
        return 1

if __name__ == "__main__":
    sys.exit(main() or 0)
